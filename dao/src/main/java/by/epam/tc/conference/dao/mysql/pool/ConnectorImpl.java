package by.epam.tc.conference.dao.mysql.pool;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * Proxy that manages connections. Holds different connection for each thread.
 * On demand retrieves connection from connection pool and holds it till the
 * end of operation or transaction. Client should invoke {@link #closeConnection()}
 * or finish transaction to release connection
 */
public class ConnectorImpl implements Connector {

    private final ConnectionPool connectionPool;
    private final ThreadLocal<Connection> localConnection;
    private final ThreadLocal<Integer> transactionStackSize;

    public ConnectorImpl(ConnectionPool connectionPool) {
        this.connectionPool = connectionPool;
        localConnection = ThreadLocal.withInitial(connectionPool::takeConnection);
        transactionStackSize = ThreadLocal.withInitial(() -> 0);
    }

    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException,
            ConnectionPoolException {
        Connection connection = localConnection.get();
        return connection.prepareStatement(sql, autoGeneratedKeys);
    }

    public void startTransaction() throws SQLException {
        Connection connection = localConnection.get();
        connection.setAutoCommit(false);
        incrementStackSize();
    }

    public void commitTransaction() throws SQLException {
        if (transactionStackSize.get() == 0) {
            throw new IllegalStateException("Transaction wasn't started. So you can't commit");
        }
        decrementTransactionCount();
        if (transactionStackSize.get() == 0) {
            Connection connection = localConnection.get();
            connection.commit();
            connection.setAutoCommit(true);
            closeConnection();
        }
    }

    public void rollback() throws SQLException {
        if (transactionStackSize.get() == 0) {
            throw new IllegalStateException("Transaction wasn't started. So you can't rollback");
        }
        Connection connection = localConnection.get();
        connection.rollback();
        connection.setAutoCommit(true);
        closeConnection();
        transactionStackSize.set(0);
    }

    public void closeConnection() {
        Integer integer = transactionStackSize.get();
        if (integer == 0) {
            Connection connection = localConnection.get();
            connectionPool.putConnection(connection);
            localConnection.remove();
        }
    }

    private void incrementStackSize() {
        Integer stackSize = transactionStackSize.get();
        stackSize++;
        transactionStackSize.set(stackSize);
    }

    private void decrementTransactionCount() {
        Integer stackSize = transactionStackSize.get();
        if (--stackSize < 0) {
            transactionStackSize.set(0);
            closeConnection();
            throw new IllegalStateException("Transaction count can't be negative");
        }
        transactionStackSize.set(stackSize);
    }
}
