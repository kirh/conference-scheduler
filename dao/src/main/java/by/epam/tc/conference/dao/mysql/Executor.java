package by.epam.tc.conference.dao.mysql;

import by.epam.tc.conference.dao.DaoException;
import by.epam.tc.conference.dao.mysql.connectionpool.ConnectionPoolException;
import by.epam.tc.conference.dao.mysql.connectionpool.Connector;
import by.epam.tc.conference.entity.Identifiable;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Optional;

public class Executor<T extends Identifiable> {

    private final Connector connector;
    private final ResultHandler<T> resultHandler;

    public Executor(Connector connector, ResultHandler<T> resultHandler) {
        this.connector = connector;
        this.resultHandler = resultHandler;
    }

    public void executeUpdate(String query, Object... queryParams) throws
            DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.NO_GENERATED_KEYS)) {
            statement.executeUpdate();
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute update query: " + e.getMessage(), e);
        } finally {
            connector.closeConnection();
        }
    }

    public Long executeInsert(String query, Object... queryParams) throws DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.RETURN_GENERATED_KEYS)) {
            statement.executeUpdate();
            return getGeneratedId(statement);
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute update query and get id " + e.getMessage(), e);
        }
    }

    public Optional<T> executeAndFetchOne(String query, Object... queryParams) throws DaoException {
        return execute(query, resultHandler::fetchOne, queryParams);
    }

    public List<T> executeAndFetchAll(String query, Object... queryParams) throws DaoException {
        return execute(query, resultHandler::fetchAll, queryParams);
    }

    private Long getGeneratedId(PreparedStatement statement) throws DaoException, SQLException {
        try (ResultSet keysResultSet = statement.getGeneratedKeys()) {
            if (keysResultSet.next()) {
                int id = keysResultSet.getInt(1);
                return Integer.toUnsignedLong(id);
            }
            throw new DaoException("No generated key found in column ");
        }
    }

    private <R> R execute(String query, ResultSetHandler<R> handler, Object... queryParams) throws DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.NO_GENERATED_KEYS);
             ResultSet resultSet = executePrepared(statement)) {
            return handler.handle(resultSet);
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute query: " + e.getMessage(), e);
        } finally {
            connector.closeConnection();
        }
    }

    private ResultSet executePrepared(PreparedStatement statement) throws SQLException {
        statement.execute();
        return statement.getResultSet();
    }

    private PreparedStatement createStatement(String query, Object[] queryParams, int autoGeneratedKeys) throws
            SQLException,
            ConnectionPoolException {
        PreparedStatement prepareStatement = connector.prepareStatement(query, autoGeneratedKeys);
        for (int i = 0; i < queryParams.length; i++) {
            int parameterIndex = i + 1;
            prepareStatement.setObject(parameterIndex, queryParams[i]);
        }
        return prepareStatement;
    }
}
