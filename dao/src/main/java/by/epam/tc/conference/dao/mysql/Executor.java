package by.epam.tc.conference.dao.mysql;

import by.epam.tc.conference.dao.DaoException;
import by.epam.tc.conference.dao.mysql.pool.ConnectionPoolException;
import by.epam.tc.conference.dao.mysql.pool.Connector;
import by.epam.tc.conference.dao.mysql.rowmapper.RowMapper;
import by.epam.tc.conference.entity.Identifiable;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class Executor<T extends Identifiable> {

    private final Connector connector;
    private final RowMapper<T> rowMapper;

    public Executor(Connector connector, RowMapper<T> rowMapper) {
        this.connector = connector;
        this.rowMapper = rowMapper;
    }

    public void executeUpdate(String query, Object... queryParams) throws
            DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.NO_GENERATED_KEYS)) {
            statement.executeUpdate();
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute update query: " + e.getMessage(), e);
        } finally {
            connector.closeConnection();
        }
    }

    public Long executeInsert(String query, Object... queryParams) throws DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.RETURN_GENERATED_KEYS)) {
            statement.executeUpdate();
            return getGeneratedId(statement);
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute update query and get id " + e.getMessage(), e);
        } finally {
            connector.closeConnection();
        }
    }

    public Optional<T> executeAndFetchOne(String query, Object... queryParams) throws DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.NO_GENERATED_KEYS);
             ResultSet resultSet = executePrepared(statement)) {
            if (resultSet.first()) {
                T object = rowMapper.handle(resultSet);
                return Optional.of(object);
            }
            return Optional.empty();
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute query " + e.getMessage(), e);
        } finally {
            connector.closeConnection();
        }
    }

    public List<T> executeAndFetchAll(String query, Object... queryParams) throws DaoException {
        try (PreparedStatement statement = createStatement(query, queryParams, Statement.NO_GENERATED_KEYS);
             ResultSet resultSet = executePrepared(statement)) {
            List<T> objects = new ArrayList<>();
            while (resultSet.next()) {
                T object = rowMapper.handle(resultSet);
                objects.add(object);
            }
            return objects;
        } catch (SQLException | ConnectionPoolException e) {
            throw new DaoException("Failed to execute query " + e.getMessage(), e);
        }
    }

    private Long getGeneratedId(PreparedStatement statement) throws SQLException {
        try (ResultSet keysResultSet = statement.getGeneratedKeys()) {
            if (keysResultSet.next()) {
                int id = keysResultSet.getInt(1);
                return Integer.toUnsignedLong(id);
            }
            throw new SQLException("No generated key found");
        }
    }

    private ResultSet executePrepared(PreparedStatement statement) throws SQLException {
        statement.execute();
        return statement.getResultSet();
    }

    private PreparedStatement createStatement(String query, Object[] queryParams, int autoGeneratedKeys) throws
            SQLException,
            ConnectionPoolException {
        PreparedStatement prepareStatement = connector.prepareStatement(query, autoGeneratedKeys);
        for (int i = 0; i < queryParams.length; i++) {
            int parameterIndex = i + 1;
            prepareStatement.setObject(parameterIndex, queryParams[i]);
        }
        return prepareStatement;
    }
}
